---
title: "C++ 11新特性"
date: 2024-09-08 06:48:19
draft: false
categories: ["C++学习"]
tags: ["C++11"]
summary: "C++ 11新特性及语法讲解"
typora-root-url: ./..\..\..\static
---

> ### 原始字面量

主要是不希望进行转义而做的声明

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    //使用此种写法\t会原始输出不会转义成tab
    string str= R"(D:\hello\world\test.text)";
    cout << str << endl;
    return 0;
}
```

替换续行符号的写法

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str = R"(<html>
        <head>
        <title>
        海贼王
        </title>
        </head>
        <body>
        <p>
        我是要成为海贼王的男人!!!
        </p>
        </body>
        </html>)";
    cout << str << endl;

    return 0;
}
```

> ### NULL 与 nullptr

由于C++不允许void*类型直接隐式转换为其他指针类型。看一下NULL在C语言和C++语言中不同的定义

```c++
#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif
```

> ### constexpr 常量表达式

在C++11 中可用它来修饰对象或函数，指出在编译期间便可进行常量计算得出结果，用它修饰必须是编译期间能计算出结果的常量，用它来修饰构造函数时，构造函数函数体必须为空，初始化写在初始化列表里面。（这个功能用的不多，目的是为了提升效率）

> ### auto自动类型推倒------核心是使用auto时必须初始化

当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字。

```c++
    const int& a = 90;
    auto b = a;//b被推到为int
    auto& c = a;//c被推到为const int&
```

> ### decltype类型推导

decltype推导的表达式可简单可复杂，在这一点上auto是做不到的，auto只能推导已初始化的变量类型

例一：

```c++
#include <list>
#include <iostream>
using namespace std;

template <class T>
class Container
{
public:
    void func(T& c)
    {
        for (m_it = c.begin(); m_it != c.end(); ++m_it)
        {
            cout << *m_it << " ";
        }
        cout << endl;
    }
private:
    decltype(T().begin()) m_it;  // 这里不能确定迭代器类型
};

int main()
{
    const list<int> lst{ 1,2,3,4,5,6,7,8,9 };
    Container<const list<int>> obj;
    obj.func(lst);
    return 0;
}
```

例二：

```c++
#include <iostream>
using namespace std;
// R->返回值类型, T->参数1类型, U->参数2类型
template <typename R, typename T, typename U>
R add(T t, U u)
{
    return t + u;
}
int main()
{
    int x = 520;
    double y = 13.14;
    auto z = add<decltype(x + y), int, double>(x, y);
    cout << "z: " << z << endl;
    return 0;
}
```

> ### 返回类型后置

格式：前面auto用于接收后面decltype推导出的类型作为auto的初始值

auto func(参数1, 参数2, ...) -> decltype(参数表达式)

为啥要用返回类型后置？

因为作为返回值放在函数前面有些参数形参列表还没声明t,u，所以要放在后面

例子：

```c++
#include <iostream>
using namespace std;

template <typename T, typename U>
// 返回类型后置语法
auto add(T t, U u) -> decltype(t + u)
{
    return t + u;
}

int main()
{
    int x = 520;
    double y = 13.14;
    auto z = add(x, y);		// 简化之后的写法,原写法：add<int,double>(x,y)
    cout << "z: " << z << endl;
    return 0;
}
```

> ### final关键词

如果使用final修饰函数，只能修饰虚函数，这样就能阻止子类重写父类的这个函数了，test()是基类中的一个虚函数，在子类中重写了这个方法，但是不希望孙子类中继续重写这个方法了，因此在子类中将test()方法标记为final，孙子类中对这个方法就只有使用的份了。

```c++
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child : public Base
{
public:
    void test() final
    {
        cout << "Child class...";
    }
};

class GrandChild : public Child
{
public:
    // 语法错误, 不允许重写
    void test()
    {
        cout << "GrandChild class...";
    }
};
```

使用final关键字修饰过的类是不允许被继承的，也就是说这个类不能有派生类

```c++
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child final: public Base
{
public:
    void test()
    {
        cout << "Child class...";
    }
};

// error, 语法错误
class GrandChild : public Child
{
public:
};
```

> ### override关键词

override关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和final一样这个关键字要写到方法的后面，说白了就是起个检查作用，怕你重写函数名写错。

```c++
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child : public Base
{
public:
    void test() override
    {
        cout << "Child class...";
    }
};

class GrandChild : public Child
{
public:
    void testttt() override //加上override后IDE这里会报错，因为函数名拼写错误,希望重写但在父类没找到此虚函数
    {
        cout << "Child class...";
    }
};
```

> ### 通过using定义函数指针

```c++
int add(int x, double y) 
{
    return x + y;
}
int main()
{
    typedef int(*func)(int,double);
    using fun2 = int(*)(int,double);
    func f = add;
    f(2,0.9);
    //第二种写法
    (*f)(2, 3.3);
    return 0;
}
```

> ### using和typedef为模版定义别名

```c++
template<typename T>
class Container 
{
public:
    void print(T& t) {
        auto it = t.begin();
        for (; it != t.end();++it) {
            std::cout << it->first << "," << it->second << endl;
        }
    }
};
//使用typedef给类型起别名，在外面使用的时候必须包裹
template<typename T>
struct MyMap 
{
    typedef map<int, T> mapType;
};
//使用using给类型起别名，无需包裹
template<typename T>
using NewMap = map<int, T>;

int main()
{ 
    //typedef使用
    MyMap<int>::mapType mm1;
    mm1.insert(make_pair(1,1));
    mm1.insert(make_pair(2, 2));
    MyMap<string>::mapType mm2;
    mm2.insert(make_pair(1, "b"));
    mm2.insert(make_pair(2, "c"));
    Container<MyMap<string>::mapType> c;
    c.print(mm2);
    //using使用
    NewMap<double> mm3;
    mm3.insert(make_pair(1, 2.3));
    mm3.insert(make_pair(2, 4.6));
    Container<NewMap<double>> c2;
    c2.print(mm3);
    return 0;
}
```

> ### 委托构造函数---解决代码冗余问题

```c++
class Test
{
public:
    Test() {};
    Test(int max)
    {
        this->m_max = max > 0 ? max : 100;
    }

    Test(int max, int min)
    {
        this->m_max = max > 0 ? max : 100;              // 冗余代码
        this->m_min = min > 0 && min < max ? min : 1;   
    }

    Test(int max, int min, int mid)
    {
        this->m_max = max > 0 ? max : 100;             // 冗余代码
        this->m_min = min > 0 && min < max ? min : 1;  // 冗余代码
        this->m_middle = mid < max && mid > min ? mid : 50;
    }

    int m_min;
    int m_max;
    int m_middle;
};
```

在一个构造函数中调用了其他的构造函数用于相关数据的初始化，相当于是一个链式调用

```c++
class Test
{
public:
    Test() {};
    Test(int max)
    {
        this->m_max = max > 0 ? max : 100;
    }

    Test(int max, int min):Test(max)
    {
        this->m_min = min > 0 && min < max ? min : 1;
    }

    Test(int max, int min, int mid):Test(max, min)
    {
        this->m_middle = mid < max && mid > min ? mid : 50;
    }

    int m_min;
    int m_max;
    int m_middle;
};
```

> ### 继承构造函数---解决冗余问题

```c++
//这是之前处理方式
#include <iostream>
#include <string>
using namespace std;

class Base
{
public:
    Base(int i) :m_i(i) {}
    Base(int i, double j) :m_i(i), m_j(j) {}
    Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {}

    int m_i;
    double m_j;
    string m_k;
};

class Child : public Base
{
public:
    Child(int i) :Base(i) {}
    Child(int i, double j) :Base(i, j) {}
    Child(int i, double j, string k) :Base(i, j, k) {}
};

int main()
{
    Child c(520, 13.14, "i love you");
    cout << "int: " << c.m_i << ", double: " 
         << c.m_j << ", string: " << c.m_k << endl;
    return 0;
}
//这是新的写法
#include <iostream>
#include <string>
using namespace std;

class Base
{
public:
    Base(int i) :m_i(i) {}
    Base(int i, double j) :m_i(i), m_j(j) {}
    Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {}

    int m_i;
    double m_j;
    string m_k;
};

class Child : public Base
{
public:
    using Base::Base;
};

int main()
{
    Child c1(520, 13.14);
    cout << "int: " << c1.m_i << ", double: " << c1.m_j << endl;
    Child c2(520, 13.14, "i love you");
    cout << "int: " << c2.m_i << ", double: " 
         << c2.m_j << ", string: " << c2.m_k << endl;
    return 0;
}
```

> ### 可调用对象

分为四大类：

1、函数指针。

```c++
int print(int a, double b)
{
    cout << a << b << endl;
    return 0;
}
// 定义函数指针
using func = int (*)(int, double);
```

2、一个具有operator()成员函数的类对象（仿函数）。

```C++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

struct Test
{
    // ()操作符重载
    void operator()(string msg)
    {
        cout << "msg: " << msg << endl;
    }
};

int main(void)
{
    Test t;
    t("我是要成为海贼王的男人!!!");	// 仿函数
    return 0;
}
```

3、一个可转换为函数指针的类对象（了解）。

```C++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

using func_ptr = void(*)(int, string);
struct Test
{
    static void print(int a, string b)
    {
        cout << "name: " << b << ", age: " << a << endl;
    }

    // 将类对象转换为函数指针
    operator func_ptr()
    {
        return print;
    }
};

int main(void)
{
    Test t;
    // 对象转换为函数指针, 并调用
    t(19, "Monkey D. Luffy");

    return 0;
}
```

4、一个类成员函数指针或类成员指针。(加上Test::是为了声明函数指针的作用域否则指向类成员编译报错)

```c++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

struct Test
{
    void print(int a, string b)
    {
        cout << "name: " << b << ", age: " << a << endl;
    }
    int m_num;
};

int main(void)
{
    // 定义类成员函数指针指向类成员函数
    void (Test::*func_ptr)(int, string) = &Test::print;
    // 类成员指针指向类成员变量
    int Test::*obj_ptr = &Test::m_num;

    Test t;
    // 通过类成员函数指针调用类成员函数
    (t.*func_ptr)(19, "Monkey D. Luffy");
    // 通过类成员指针初始化类成员变量
    t.*obj_ptr = 1;
    cout << "number is: " << t.m_num << endl;

    return 0;
}
```

> ### 可调用对象包装器（上面四种可调用对象打包成一种，以一种统一的方式使用）

std::function必须要包含一个叫做functional的头文件，可调用对象包装器使用语法如下:

```c++
#include <functional>
std::function<返回值类型(参数类型列表)> diy_name = 可调用对象;
```

1、包装普通函数
