---
title: "C++ 11新特性"
date: 2024-09-08 06:48:19
draft: false
categories: ["C++学习"]
tags: ["C++11"]
summary: "C++ 11新特性及语法讲解"
typora-root-url: ./..\..\..\static
---

> ### 原始字面量

主要是不希望进行转义而做的声明

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    //使用此种写法\t会原始输出不会转义成tab
    string str= R"(D:\hello\world\test.text)";
    cout << str << endl;
    return 0;
}
```

替换续行符号的写法

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str = R"(<html>
        <head>
        <title>
        海贼王
        </title>
        </head>
        <body>
        <p>
        我是要成为海贼王的男人!!!
        </p>
        </body>
        </html>)";
    cout << str << endl;

    return 0;
}
```

> ### NULL 与 nullptr

由于C++不允许void*类型直接隐式转换为其他指针类型。看一下NULL在C语言和C++语言中不同的定义

```c++
#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif
```

> ### constexpr 常量表达式

在C++11 中可用它来修饰对象或函数，指出在编译期间便可进行常量计算得出结果，用它修饰必须是编译期间能计算出结果的常量，用它来修饰构造函数时，构造函数函数体必须为空，初始化写在初始化列表里面。（这个功能用的不多，目的是为了提升效率）

> ### auto自动类型推倒------核心是使用auto时必须初始化

当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字。

```c++
    const int& a = 90;
    auto b = a;//b被推到为int
    auto& c = a;//c被推到为const int&
```

> ### decltype类型推导

decltype推导的表达式可简单可复杂，在这一点上auto是做不到的，auto只能推导已初始化的变量类型

例一：

```c++
#include <list>
#include <iostream>
using namespace std;

template <class T>
class Container
{
public:
    void func(T& c)
    {
        for (m_it = c.begin(); m_it != c.end(); ++m_it)
        {
            cout << *m_it << " ";
        }
        cout << endl;
    }
private:
    decltype(T().begin()) m_it;  // 这里不能确定迭代器类型
};

int main()
{
    const list<int> lst{ 1,2,3,4,5,6,7,8,9 };
    Container<const list<int>> obj;
    obj.func(lst);
    return 0;
}
```

例二：

```c++
#include <iostream>
using namespace std;
// R->返回值类型, T->参数1类型, U->参数2类型
template <typename R, typename T, typename U>
R add(T t, U u)
{
    return t + u;
}
int main()
{
    int x = 520;
    double y = 13.14;
    auto z = add<decltype(x + y), int, double>(x, y);
    cout << "z: " << z << endl;
    return 0;
}
```

> ### 返回类型后置

格式：前面auto用于接收后面decltype推导出的类型作为auto的初始值

auto func(参数1, 参数2, ...) -> decltype(参数表达式)

为啥要用返回类型后置？

因为作为返回值放在函数前面有些参数形参列表还没声明t,u，所以要放在后面

例子：

```c++
#include <iostream>
using namespace std;

template <typename T, typename U>
// 返回类型后置语法
auto add(T t, U u) -> decltype(t + u)
{
    return t + u;
}

int main()
{
    int x = 520;
    double y = 13.14;
    auto z = add(x, y);		// 简化之后的写法,原写法：add<int,double>(x,y)
    cout << "z: " << z << endl;
    return 0;
}
```

> ### final关键词

如果使用final修饰函数，只能修饰虚函数，这样就能阻止子类重写父类的这个函数了，test()是基类中的一个虚函数，在子类中重写了这个方法，但是不希望孙子类中继续重写这个方法了，因此在子类中将test()方法标记为final，孙子类中对这个方法就只有使用的份了。

```c++
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child : public Base
{
public:
    void test() final
    {
        cout << "Child class...";
    }
};

class GrandChild : public Child
{
public:
    // 语法错误, 不允许重写
    void test()
    {
        cout << "GrandChild class...";
    }
};
```

使用final关键字修饰过的类是不允许被继承的，也就是说这个类不能有派生类

```c++
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child final: public Base
{
public:
    void test()
    {
        cout << "Child class...";
    }
};

// error, 语法错误
class GrandChild : public Child
{
public:
};
```

> ### override关键词

override关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和final一样这个关键字要写到方法的后面，说白了就是起个检查作用，怕你重写函数名写错。

```c++
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child : public Base
{
public:
    void test() override
    {
        cout << "Child class...";
    }
};

class GrandChild : public Child
{
public:
    void testttt() override //加上override后IDE这里会报错，因为函数名拼写错误,希望重写但在父类没找到此虚函数
    {
        cout << "Child class...";
    }
};
```

> ### 通过using定义函数指针

```c++
int add(int x, double y) 
{
    return x + y;
}
int main()
{
    typedef int(*func)(int,double);
    using fun2 = int(*)(int,double);
    func f = add;
    f(2,0.9);
    //第二种写法
    (*f)(2, 3.3);
    return 0;
}
```

> ### using和typedef为模版定义别名

```c++
template<typename T>
class Container 
{
public:
    void print(T& t) {
        auto it = t.begin();
        for (; it != t.end();++it) {
            std::cout << it->first << "," << it->second << endl;
        }
    }
};
//使用typedef给类型起别名，在外面使用的时候必须包裹
template<typename T>
struct MyMap 
{
    typedef map<int, T> mapType;
};
//使用using给类型起别名，无需包裹
template<typename T>
using NewMap = map<int, T>;

int main()
{ 
    //typedef使用
    MyMap<int>::mapType mm1;
    mm1.insert(make_pair(1,1));
    mm1.insert(make_pair(2, 2));
    MyMap<string>::mapType mm2;
    mm2.insert(make_pair(1, "b"));
    mm2.insert(make_pair(2, "c"));
    Container<MyMap<string>::mapType> c;
    c.print(mm2);
    //using使用
    NewMap<double> mm3;
    mm3.insert(make_pair(1, 2.3));
    mm3.insert(make_pair(2, 4.6));
    Container<NewMap<double>> c2;
    c2.print(mm3);
    return 0;
}
```

