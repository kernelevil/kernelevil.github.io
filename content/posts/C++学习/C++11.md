---
title: "C++ 11新特性"
date: 2024-09-08 06:48:19
draft: false
categories: ["C++学习"]
tags: ["C++11"]
summary: "C++ 11新特性及语法讲解"
typora-root-url: ./..\..\..\static
---

> ### 原始字面量

主要是不希望进行转义而做的声明

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    //使用此种写法\t会原始输出不会转义成tab
    string str= R"(D:\hello\world\test.text)";
    cout << str << endl;
    return 0;
}
```

替换续行符号的写法

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str = R"(<html>
        <head>
        <title>
        海贼王
        </title>
        </head>
        <body>
        <p>
        我是要成为海贼王的男人!!!
        </p>
        </body>
        </html>)";
    cout << str << endl;

    return 0;
}
```

> ### NULL 与 nullptr

由于C++不允许void*类型直接隐式转换为其他指针类型。看一下NULL在C语言和C++语言中不同的定义

```c++
#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif
```

> ### constexpr 常量表达式

在C++11 中可用它来修饰对象或函数，指出在编译期间便可进行常量计算得出结果，用它修饰必须是编译期间能计算出结果的常量，用它来修饰构造函数时，构造函数函数体必须为空，初始化写在初始化列表里面。（这个功能用的不多，目的是为了提升效率）

> ### auto自动类型推倒------核心是使用auto时必须初始化

当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字。

```c++
    const int& a = 90;
    auto b = a;//b被推到为int
    auto& c = a;//c被推到为const int&
```

> ### decltype类型推导

decltype推导的表达式可简单可复杂，在这一点上auto是做不到的，auto只能推导已初始化的变量类型

例一：

```c++
#include <list>
#include <iostream>
using namespace std;

template <class T>
class Container
{
public:
    void func(T& c)
    {
        for (m_it = c.begin(); m_it != c.end(); ++m_it)
        {
            cout << *m_it << " ";
        }
        cout << endl;
    }
private:
    decltype(T().begin()) m_it;  // 这里不能确定迭代器类型
};

int main()
{
    const list<int> lst{ 1,2,3,4,5,6,7,8,9 };
    Container<const list<int>> obj;
    obj.func(lst);
    return 0;
}
```

例二：

```c++
#include <iostream>
using namespace std;
// R->返回值类型, T->参数1类型, U->参数2类型
template <typename R, typename T, typename U>
R add(T t, U u)
{
    return t + u;
}
int main()
{
    int x = 520;
    double y = 13.14;
    auto z = add<decltype(x + y), int, double>(x, y);
    cout << "z: " << z << endl;
    return 0;
}
```

> ### 返回类型后置

格式：前面auto用于接收后面decltype推导出的类型作为auto的初始值

auto func(参数1, 参数2, ...) -> decltype(参数表达式)

为啥要用返回类型后置？

因为作为返回值放在函数前面有些参数形参列表还没声明，所以要放在后面

例子：

```c++
#include <iostream>
using namespace std;

template <typename T, typename U>
// 返回类型后置语法
auto add(T t, U u) -> decltype(t + u)
{
    return t + u;
}

int main()
{
    int x = 520;
    double y = 13.14;
    auto z = add(x, y);		// 简化之后的写法,原写法：add<int,double>(x,y)
    cout << "z: " << z << endl;
    return 0;
}
```

